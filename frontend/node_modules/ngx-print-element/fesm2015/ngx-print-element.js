import { Injectable, NgModule, Component, Directive, HostListener, Input, defineInjectable } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * callPrint
 * \@param printWindow
 * \@param iframe
 * @type {?}
 */
const callPrint = (/**
 * @param {?} printWindow
 * @param {?} iframe
 * @return {?}
 */
(printWindow, iframe) => {
    if (printWindow && printWindow.printPage) {
        printWindow.printPage();
        if (iframe) {
            document.body.removeChild(iframe);
        }
    }
    else {
        setTimeout((/**
         * @return {?}
         */
        () => {
            callPrint(printWindow, iframe);
        }), 50);
    }
});
/**
 * getBaseHref
 * \@return
 * @type {?}
 */
const getBaseHref = (/**
 * @return {?}
 */
() => {
    /** @type {?} */
    const port = (window.location.port) ? `:${window.location.port}` : '';
    return `${window.location.protocol}//${window.location.hostname}${port}${window.location.pathname}`;
});
/**
 * getMarkup
 * \@param elementHtml
 * \@param options
 * \@return
 * @type {?}
 */
const getMarkup = (/**
 * @param {?} elementHtml
 * @param {?} options
 * @return {?}
 */
(elementHtml, options) => {
    /** @type {?} */
    const template = options.templateString;
    /** @type {?} */
    const templateRegex = new RegExp(/{{\s*printBody\s*}}/gi);
    /** @type {?} */
    let stylesheets;
    /** @type {?} */
    let styles;
    /** @type {?} */
    const html = [];
    if (template && templateRegex.test(template)) {
        elementHtml = template.replace(templateRegex, elementHtml);
    }
    html.push(`<html><head><title>${options.pageTitle || ''}</title>`);
    // If stylesheet URL's or list of stylesheet URL's are specified, override page stylesheets
    if (options.stylesheets) {
        stylesheets = Array.isArray(options.stylesheets) ? options.stylesheets : [options.stylesheets];
    }
    else {
        stylesheets = Array.prototype.slice
            .call(document.getElementsByTagName('link'))
            .map((/**
         * @param {?} link
         * @return {?}
         */
        link => link));
    }
    stylesheets.forEach((/**
     * @param {?} f
     * @return {?}
     */
    (f) => {
        html.push(`<link rel="${f.rel}" href="${f.href}">`);
    }));
    // If inline styles or list of inline styles are specified, override inline styles
    if (options.styles) {
        styles = Array.isArray(options.styles) ? [...options.styles, `.print-none { display: none; }`] : [options.styles + `.print-none { display: none; }`];
    }
    else {
        styles = Array.prototype.slice
            .call(document.getElementsByTagName('style'))
            .map((/**
         * @param {?} style
         * @return {?}
         */
        style => style.innerHTML));
    }
    styles.forEach((/**
     * @param {?} style
     * @return {?}
     */
    (style) => {
        html.push(`<style type="text/css">${style}</style>`);
    }));
    html.push(`<base href="${getBaseHref()}"/>`);
    html.push('</head><body class="pe-body">');
    html.push(elementHtml);
    html.push(`
    <script type="text/javascript">
      function printPage() {
        focus();
        print();
        ${options.printMode.toLowerCase() === 'popup' ? 'close();' : ''}
      }
    </script>
  `);
    html.push('</body></html>');
    return html.join('');
});
/**
 * printHtml
 * \@param element
 * \@param selfOptions
 * @type {?}
 */
const printHtml = (/**
 * @param {?} element
 * @param {?=} selfOptions
 * @return {?}
 */
(element, selfOptions = {}) => {
    /** @type {?} */
    const defaultOptions = {
        htmlType: 'domObj',
        printMode: 'template',
        pageTitle: '',
        templateString: '',
        popupProperties: '',
        stylesheets: null,
        styles: null
    };
    /** @type {?} */
    const options = Object.assign({}, defaultOptions, selfOptions);
    /** @type {?} */
    let html = element;
    if (options.htmlType === 'domObj') {
        html = element.outerHTML;
    }
    // Get markup to be printed
    /** @type {?} */
    const markup = getMarkup(html, options);
    /** @type {?} */
    let printWindow;
    /** @type {?} */
    let printIframe;
    /** @type {?} */
    let printDocument;
    /** @type {?} */
    let printElementID;
    if (options.printMode.toLowerCase() === 'popup') {
        printWindow = window.open('about:blank', 'printElementWindow', options.popupProperties);
        printDocument = printWindow && printWindow.document;
    }
    else {
        printElementID = `printElement_${(Math.round(Math.random() * 99999)).toString()}`;
        printIframe = document.createElement('iframe');
        printIframe.setAttribute('id', printElementID);
        printIframe.setAttribute('src', 'about:blank');
        printIframe.setAttribute('frameBorder', '0');
        printIframe.setAttribute('scrolling', 'no');
        printIframe.setAttribute('style', 'position:fixed;bottom:100%;right:100%;');
        document.body.appendChild(printIframe);
        printDocument = (printIframe.contentWindow || printIframe.contentDocument);
        if (printDocument.document) {
            printDocument = printDocument.document;
        }
        printIframe = ((/** @type {?} */ (document))).frames ? ((/** @type {?} */ (document))).frames[printElementID] : document.getElementById(printElementID);
        printWindow = printIframe.contentWindow || printIframe;
    }
    focus();
    printDocument.open();
    // SetTimeout fixesiframe printMode does not work in firefox
    setTimeout((/**
     * @return {?}
     */
    () => {
        printDocument.write(markup);
        printDocument.close();
    }));
    callPrint(printWindow, printIframe);
});

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrintElementService {
    /**
     * Print
     * @param {?} id
     * @param {?=} config
     * @return {?}
     */
    print(id, config) {
        // Create and insert new print section
        /** @type {?} */
        const container = document.getElementById(id);
        switch (config && config.printMode) {
            case 'template':
                printHtml(container, Object.assign({}, config, { printMode: '' }));
                break;
            case 'template-popup':
                printHtml(container, Object.assign({}, config, { printMode: 'popup' }));
                break;
            default:
                if (container) {
                    // Declare
                    /** @type {?} */
                    const domClone = container.cloneNode(true);
                    /** @type {?} */
                    const $printSection = document.createElement('div');
                    // Add visibility hidden into body
                    /** @type {?} */
                    const bodyEl = document.querySelector('body');
                    if (bodyEl) {
                        bodyEl.setAttribute('style', 'visibility: hidden !important;');
                    }
                    // Clone element container
                    $printSection.id = 'ngx-print-element';
                    $printSection.appendChild(domClone);
                    document.body.insertBefore($printSection, document.body.firstChild);
                    // Print
                    window.print();
                    // Clean up print section for future use
                    /** @type {?} */
                    const oldElem = document.getElementById('ngx-print-element');
                    if (oldElem) {
                        oldElem.parentNode && oldElem.parentNode.removeChild(oldElem);
                        oldElem.remove();
                    }
                    // Clear visibility: hidden
                    bodyEl && (bodyEl.style.visibility = '');
                }
                break;
        }
    }
}
NgxPrintElementService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */ NgxPrintElementService.ngInjectableDef = defineInjectable({ factory: function NgxPrintElementService_Factory() { return new NgxPrintElementService(); }, token: NgxPrintElementService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrintElementDirective {
    /**
     * @param {?} prints
     */
    constructor(prints) {
        this.prints = prints;
        this.print = [];
    }
    /**
     * Print
     * @param {?} event
     * @return {?}
     */
    onClick(event) {
        if (this.print && this.print.length === 1) {
            this.prints.print(this.print[0]);
        }
        if (this.print && this.print.length === 2) {
            this.prints.print(this.print[0], this.print[1]);
        }
    }
}
NgxPrintElementDirective.decorators = [
    { type: Directive, args: [{
                selector: '[print]'
            },] }
];
NgxPrintElementDirective.ctorParameters = () => [
    { type: NgxPrintElementService }
];
NgxPrintElementDirective.propDecorators = {
    print: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrintElementComponent {
    /**
     * @param {?} prints
     */
    constructor(prints) {
        this.prints = prints;
    }
    /**
     * print
     * @param {?} id
     * @param {?=} config
     * @return {?}
     */
    print(id, config) {
        this.prints.print(id, config);
    }
}
NgxPrintElementComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-print-element',
                template: `<ng-content></ng-content>`,
                exportAs: 'element'
            }] }
];
NgxPrintElementComponent.ctorParameters = () => [
    { type: NgxPrintElementService }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxPrintElementModule {
}
NgxPrintElementModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    NgxPrintElementComponent,
                    NgxPrintElementDirective
                ],
                exports: [
                    NgxPrintElementComponent,
                    NgxPrintElementDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxPrintElementDirective, NgxPrintElementService, NgxPrintElementComponent, NgxPrintElementModule };

//# sourceMappingURL=ngx-print-element.js.map