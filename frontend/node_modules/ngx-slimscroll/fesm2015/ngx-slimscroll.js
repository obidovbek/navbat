import { InjectionToken, EventEmitter, Directive, ViewContainerRef, Inject, Renderer2, Optional, Input, Output, HostListener, NgModule } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { fromEvent, merge, Subscription } from 'rxjs';
import { mergeMap, map, takeUntil } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * Generated from: src/classes/slimscroll-event.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ISlimScrollEvent() { }
if (false) {
    /** @type {?} */
    ISlimScrollEvent.prototype.type;
    /** @type {?|undefined} */
    ISlimScrollEvent.prototype.y;
    /** @type {?|undefined} */
    ISlimScrollEvent.prototype.percent;
    /** @type {?|undefined} */
    ISlimScrollEvent.prototype.duration;
    /** @type {?|undefined} */
    ISlimScrollEvent.prototype.easing;
}
class SlimScrollEvent {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.type = obj.type;
        this.y = obj && obj.y ? obj.y : 0;
        this.percent = obj && obj.percent ? obj.percent : 0;
        this.duration = obj && obj.duration ? obj.duration : 0;
        this.easing = obj && obj.easing ? obj.easing : 'linear';
    }
}
if (false) {
    /** @type {?} */
    SlimScrollEvent.prototype.type;
    /** @type {?} */
    SlimScrollEvent.prototype.y;
    /** @type {?} */
    SlimScrollEvent.prototype.percent;
    /** @type {?} */
    SlimScrollEvent.prototype.duration;
    /** @type {?} */
    SlimScrollEvent.prototype.easing;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/classes/slimscroll-options.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ISlimScrollOptions() { }
if (false) {
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.position;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.barBackground;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.barOpacity;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.barWidth;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.barBorderRadius;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.barMargin;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.gridBackground;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.gridOpacity;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.gridWidth;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.gridBorderRadius;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.gridMargin;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.alwaysVisible;
    /** @type {?|undefined} */
    ISlimScrollOptions.prototype.visibleTimeout;
}
/** @type {?} */
const SLIMSCROLL_DEFAULTS = new InjectionToken('NGX_SLIMSCROLL_DEFAULTS');
class SlimScrollOptions {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.position = obj && obj.position ? obj.position : 'right';
        this.barBackground = obj && obj.barBackground ? obj.barBackground : '#343a40';
        this.barOpacity = obj && obj.barOpacity ? obj.barOpacity : '1';
        this.barWidth = obj && obj.barWidth ? obj.barWidth : '12';
        this.barBorderRadius = obj && obj.barBorderRadius ? obj.barBorderRadius : '5';
        this.barMargin = obj && obj.barMargin ? obj.barMargin : '1px 0';
        this.gridBackground = obj && obj.gridBackground ? obj.gridBackground : '#adb5bd';
        this.gridOpacity = obj && obj.gridOpacity ? obj.gridOpacity : '1';
        this.gridWidth = obj && obj.gridWidth ? obj.gridWidth : '8';
        this.gridBorderRadius = obj && obj.gridBorderRadius ? obj.gridBorderRadius : '10';
        this.gridMargin = obj && obj.gridMargin ? obj.gridMargin : '1px 2px';
        this.alwaysVisible = obj && typeof obj.alwaysVisible !== 'undefined' ? obj.alwaysVisible : true;
        this.visibleTimeout = obj && obj.visibleTimeout ? obj.visibleTimeout : 1000;
    }
    /**
     * @param {?=} obj
     * @return {?}
     */
    merge(obj) {
        /** @type {?} */
        const result = new SlimScrollOptions();
        result.position = obj && obj.position ? obj.position : this.position;
        result.barBackground = obj && obj.barBackground ? obj.barBackground : this.barBackground;
        result.barOpacity = obj && obj.barOpacity ? obj.barOpacity : this.barOpacity;
        result.barWidth = obj && obj.barWidth ? obj.barWidth : this.barWidth;
        result.barBorderRadius = obj && obj.barBorderRadius ? obj.barBorderRadius : this.barBorderRadius;
        result.barMargin = obj && obj.barMargin ? obj.barMargin : this.barMargin;
        result.gridBackground = obj && obj.gridBackground ? obj.gridBackground : this.gridBackground;
        result.gridOpacity = obj && obj.gridOpacity ? obj.gridOpacity : this.gridOpacity;
        result.gridWidth = obj && obj.gridWidth ? obj.gridWidth : this.gridWidth;
        result.gridBorderRadius = obj && obj.gridBorderRadius ? obj.gridBorderRadius : this.gridBorderRadius;
        result.gridMargin = obj && obj.gridMargin ? obj.gridMargin : this.gridMargin;
        result.alwaysVisible = obj && typeof obj.alwaysVisible !== 'undefined' ? obj.alwaysVisible : this.alwaysVisible;
        result.visibleTimeout = obj && obj.visibleTimeout ? obj.visibleTimeout : this.visibleTimeout;
        return result;
    }
}
if (false) {
    /** @type {?} */
    SlimScrollOptions.prototype.position;
    /** @type {?} */
    SlimScrollOptions.prototype.barBackground;
    /** @type {?} */
    SlimScrollOptions.prototype.barOpacity;
    /** @type {?} */
    SlimScrollOptions.prototype.barWidth;
    /** @type {?} */
    SlimScrollOptions.prototype.barBorderRadius;
    /** @type {?} */
    SlimScrollOptions.prototype.barMargin;
    /** @type {?} */
    SlimScrollOptions.prototype.gridBackground;
    /** @type {?} */
    SlimScrollOptions.prototype.gridOpacity;
    /** @type {?} */
    SlimScrollOptions.prototype.gridWidth;
    /** @type {?} */
    SlimScrollOptions.prototype.gridBorderRadius;
    /** @type {?} */
    SlimScrollOptions.prototype.gridMargin;
    /** @type {?} */
    SlimScrollOptions.prototype.alwaysVisible;
    /** @type {?} */
    SlimScrollOptions.prototype.visibleTimeout;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/classes/slimscroll-state.class.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function ISlimScrollState() { }
if (false) {
    /** @type {?} */
    ISlimScrollState.prototype.scrollPosition;
    /** @type {?} */
    ISlimScrollState.prototype.isScrollAtStart;
    /** @type {?} */
    ISlimScrollState.prototype.isScrollAtEnd;
}
class SlimScrollState {
    /**
     * @param {?=} obj
     */
    constructor(obj) {
        this.scrollPosition = obj && obj.scrollPosition ? obj.scrollPosition : 0;
        this.isScrollAtStart = obj && typeof obj.isScrollAtStart !== 'undefined' ? obj.isScrollAtStart : true;
        this.isScrollAtEnd = obj && typeof obj.isScrollAtEnd !== 'undefined' ? obj.isScrollAtEnd : false;
    }
}
if (false) {
    /** @type {?} */
    SlimScrollState.prototype.scrollPosition;
    /** @type {?} */
    SlimScrollState.prototype.isScrollAtStart;
    /** @type {?} */
    SlimScrollState.prototype.isScrollAtEnd;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/directives/slimscroll.directive.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t, ɵ1 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t * t, ɵ2 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t * (2 - t), ɵ3 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t, ɵ4 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t * t * t, ɵ5 = /**
 * @param {?} t
 * @return {?}
 */
(t) => (--t) * t * t + 1, ɵ6 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1, ɵ7 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t * t * t * t, ɵ8 = /**
 * @param {?} t
 * @return {?}
 */
(t) => 1 - (--t) * t * t * t, ɵ9 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t < .5 ? 8 * t * t * t * t : 1 - 8 * (--t) * t * t * t, ɵ10 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t * t * t * t * t, ɵ11 = /**
 * @param {?} t
 * @return {?}
 */
(t) => 1 + (--t) * t * t * t * t, ɵ12 = /**
 * @param {?} t
 * @return {?}
 */
(t) => t < .5 ? 16 * t * t * t * t * t : 1 + 16 * (--t) * t * t * t * t;
/** @type {?} */
const easing = {
    linear: (ɵ0),
    inQuad: (ɵ1),
    outQuad: (ɵ2),
    inOutQuad: (ɵ3),
    inCubic: (ɵ4),
    outCubic: (ɵ5),
    inOutCubic: (ɵ6),
    inQuart: (ɵ7),
    outQuart: (ɵ8),
    inOutQuart: (ɵ9),
    inQuint: (ɵ10),
    outQuint: (ɵ11),
    inOutQuint: (ɵ12)
};
class SlimScrollDirective {
    /**
     * @param {?} viewContainer
     * @param {?} renderer
     * @param {?} document
     * @param {?} optionsDefaults
     */
    constructor(viewContainer, renderer, document, optionsDefaults) {
        this.viewContainer = viewContainer;
        this.renderer = renderer;
        this.document = document;
        this.optionsDefaults = optionsDefaults;
        this.enabled = true;
        this.scrollChanged = new EventEmitter();
        this.barVisibilityChange = new EventEmitter();
        this.initWheel = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const dommousescroll = fromEvent(this.el, 'DOMMouseScroll');
            /** @type {?} */
            const mousewheel = fromEvent(this.el, 'mousewheel');
            /** @type {?} */
            const wheelSubscription = merge(...[dommousescroll, mousewheel]).subscribe((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                /** @type {?} */
                let delta = 0;
                if (((/** @type {?} */ (e))).wheelDelta) {
                    delta = -((/** @type {?} */ (e))).wheelDelta / 120;
                }
                if (e.detail) {
                    delta = e.detail / 3;
                }
                this.scrollContent(delta, true, false);
                if (e.preventDefault) {
                    e.preventDefault();
                }
            }));
            this.interactionSubscriptions.add(wheelSubscription);
        });
        this.initDrag = (/**
         * @return {?}
         */
        () => {
            /** @type {?} */
            const bar = this.bar;
            /** @type {?} */
            const mousemove = fromEvent(this.document.documentElement, 'mousemove');
            /** @type {?} */
            const touchmove = fromEvent(this.document.documentElement, 'touchmove');
            /** @type {?} */
            const mousedown = fromEvent(bar, 'mousedown');
            /** @type {?} */
            const touchstart = fromEvent(this.el, 'touchstart');
            /** @type {?} */
            const mouseup = fromEvent(this.document.documentElement, 'mouseup');
            /** @type {?} */
            const touchend = fromEvent(this.document.documentElement, 'touchend');
            /** @type {?} */
            const mousedrag = mousedown
                .pipe(mergeMap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.pageY = e.pageY;
                this.top = parseFloat(getComputedStyle(bar).top);
                return mousemove
                    .pipe(map((/**
                 * @param {?} emove
                 * @return {?}
                 */
                (emove) => {
                    emove.preventDefault();
                    return this.top + emove.pageY - this.pageY;
                })), takeUntil(mouseup));
            })));
            /** @type {?} */
            const touchdrag = touchstart
                .pipe(mergeMap((/**
             * @param {?} e
             * @return {?}
             */
            (e) => {
                this.pageY = e.targetTouches[0].pageY;
                this.top = -parseFloat(getComputedStyle(bar).top);
                return touchmove
                    .pipe(map((/**
                 * @param {?} tmove
                 * @return {?}
                 */
                (tmove) => {
                    return -(this.top + tmove.targetTouches[0].pageY - this.pageY);
                })), takeUntil(touchend));
            })));
            /** @type {?} */
            const dragSubscription = merge(...[mousedrag, touchdrag]).subscribe((/**
             * @param {?} top
             * @return {?}
             */
            (top) => {
                this.body.addEventListener('selectstart', this.preventDefaultEvent, false);
                this.renderer.setStyle(this.body, 'touch-action', 'pan-y');
                this.renderer.setStyle(this.body, 'user-select', 'none');
                this.renderer.setStyle(this.bar, 'top', `${top}px`);
                /** @type {?} */
                const over = this.scrollContent(0, true, false);
                /** @type {?} */
                const maxTop = this.el.offsetHeight - this.bar.offsetHeight;
                if (over && over < 0 && -over <= maxTop) {
                    this.renderer.setStyle(this.el, 'paddingTop', -over + 'px');
                }
                else if (over && over > 0 && over <= maxTop) {
                    this.renderer.setStyle(this.el, 'paddingBottom', over + 'px');
                }
            }));
            /** @type {?} */
            const dragEndSubscription = merge(...[mouseup, touchend]).subscribe((/**
             * @return {?}
             */
            () => {
                this.body.removeEventListener('selectstart', this.preventDefaultEvent, false);
                /** @type {?} */
                const paddingTop = parseInt(this.el.style.paddingTop, 10);
                /** @type {?} */
                const paddingBottom = parseInt(this.el.style.paddingBottom, 10);
                this.renderer.setStyle(this.body, 'touch-action', 'unset');
                this.renderer.setStyle(this.body, 'user-select', 'default');
                if (paddingTop > 0) {
                    this.scrollTo(0, 300, 'linear');
                }
                else if (paddingBottom > 0) {
                    this.scrollTo(0, 300, 'linear');
                }
            }));
            this.interactionSubscriptions.add(dragSubscription);
            this.interactionSubscriptions.add(dragEndSubscription);
        });
        this.preventDefaultEvent = (/**
         * @param {?} e
         * @return {?}
         */
        (e) => {
            e.preventDefault();
            e.stopPropagation();
        });
        this.viewContainer = viewContainer;
        this.el = viewContainer.element.nativeElement;
        this.body = this.document.querySelector('body');
        this.mutationThrottleTimeout = 50;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // setup if no changes for enabled for the first time
        if (!this.interactionSubscriptions && this.enabled) {
            this.setup();
        }
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.enabled) {
            if (this.enabled) {
                this.setup();
            }
            else {
                this.destroy();
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy();
    }
    /**
     * @return {?}
     */
    setup() {
        this.interactionSubscriptions = new Subscription();
        if (this.optionsDefaults) {
            this.options = new SlimScrollOptions(this.optionsDefaults).merge(this.options);
        }
        else {
            this.options = new SlimScrollOptions(this.options);
        }
        this.setStyle();
        this.wrapContainer();
        this.initGrid();
        this.initBar();
        this.getBarHeight();
        this.initWheel();
        this.initDrag();
        if (!this.options.alwaysVisible) {
            this.hideBarAndGrid();
        }
        if (MutationObserver) {
            if (this.mutationObserver) {
                this.mutationObserver.disconnect();
            }
            this.mutationObserver = new MutationObserver((/**
             * @return {?}
             */
            () => {
                if (this.mutationThrottleTimeout) {
                    clearTimeout(this.mutationThrottleTimeout);
                    this.mutationThrottleTimeout = setTimeout(this.onMutation.bind(this), 50);
                }
            }));
            this.mutationObserver.observe(this.el, { subtree: true, childList: true });
        }
        if (this.scrollEvents && this.scrollEvents instanceof EventEmitter) {
            /** @type {?} */
            const scrollSubscription = this.scrollEvents.subscribe((/**
             * @param {?} event
             * @return {?}
             */
            (event) => this.handleEvent(event)));
            this.interactionSubscriptions.add(scrollSubscription);
        }
    }
    /**
     * @param {?} e
     * @return {?}
     */
    handleEvent(e) {
        if (e.type === 'scrollToBottom') {
            /** @type {?} */
            const y = this.el.scrollHeight - this.el.clientHeight;
            this.scrollTo(y, e.duration, e.easing);
        }
        else if (e.type === 'scrollToTop') {
            /** @type {?} */
            const y = 0;
            this.scrollTo(y, e.duration, e.easing);
        }
        else if (e.type === 'scrollToPercent' && (e.percent >= 0 && e.percent <= 100)) {
            /** @type {?} */
            const y = Math.round(((this.el.scrollHeight - this.el.clientHeight) / 100) * e.percent);
            this.scrollTo(y, e.duration, e.easing);
        }
        else if (e.type === 'scrollTo') {
            /** @type {?} */
            const y = e.y;
            if (y <= this.el.scrollHeight - this.el.clientHeight && y >= 0) {
                this.scrollTo(y, e.duration, e.easing);
            }
        }
        else if (e.type === 'recalculate') {
            this.getBarHeight();
        }
    }
    /**
     * @return {?}
     */
    setStyle() {
        /** @type {?} */
        const el = this.el;
        this.renderer.setStyle(el, 'overflow', 'hidden');
        this.renderer.setStyle(el, 'position', 'relative');
        this.renderer.setStyle(el, 'display', 'block');
    }
    /**
     * @return {?}
     */
    onMutation() {
        this.getBarHeight();
    }
    /**
     * @return {?}
     */
    wrapContainer() {
        this.wrapper = this.renderer.createElement('div');
        /** @type {?} */
        const wrapper = this.wrapper;
        /** @type {?} */
        const el = this.el;
        this.renderer.addClass(wrapper, 'slimscroll-wrapper');
        this.renderer.setStyle(wrapper, 'position', 'relative');
        this.renderer.setStyle(wrapper, 'overflow', 'hidden');
        this.renderer.setStyle(wrapper, 'display', 'inline-block');
        this.renderer.setStyle(wrapper, 'margin', getComputedStyle(el).margin);
        this.renderer.setStyle(wrapper, 'width', '100%');
        this.renderer.setStyle(wrapper, 'height', getComputedStyle(el).height);
        this.renderer.insertBefore(el.parentNode, wrapper, el);
        this.renderer.appendChild(wrapper, el);
    }
    /**
     * @return {?}
     */
    initGrid() {
        this.grid = this.renderer.createElement('div');
        /** @type {?} */
        const grid = this.grid;
        this.renderer.addClass(grid, 'slimscroll-grid');
        this.renderer.setStyle(grid, 'position', 'absolute');
        this.renderer.setStyle(grid, 'top', '0');
        this.renderer.setStyle(grid, 'bottom', '0');
        this.renderer.setStyle(grid, this.options.position, '0');
        this.renderer.setStyle(grid, 'width', `${this.options.gridWidth}px`);
        this.renderer.setStyle(grid, 'background', this.options.gridBackground);
        this.renderer.setStyle(grid, 'opacity', this.options.gridOpacity);
        this.renderer.setStyle(grid, 'display', 'block');
        this.renderer.setStyle(grid, 'cursor', 'pointer');
        this.renderer.setStyle(grid, 'z-index', '99');
        this.renderer.setStyle(grid, 'border-radius', `${this.options.gridBorderRadius}px`);
        this.renderer.setStyle(grid, 'margin', this.options.gridMargin);
        this.renderer.appendChild(this.wrapper, grid);
    }
    /**
     * @return {?}
     */
    initBar() {
        this.bar = this.renderer.createElement('div');
        /** @type {?} */
        const bar = this.bar;
        this.renderer.addClass(bar, 'slimscroll-bar');
        this.renderer.setStyle(bar, 'position', 'absolute');
        this.renderer.setStyle(bar, 'top', '0');
        this.renderer.setStyle(bar, this.options.position, '0');
        this.renderer.setStyle(bar, 'width', `${this.options.barWidth}px`);
        this.renderer.setStyle(bar, 'background', this.options.barBackground);
        this.renderer.setStyle(bar, 'opacity', this.options.barOpacity);
        this.renderer.setStyle(bar, 'display', 'block');
        this.renderer.setStyle(bar, 'cursor', 'pointer');
        this.renderer.setStyle(bar, 'z-index', '100');
        this.renderer.setStyle(bar, 'border-radius', `${this.options.barBorderRadius}px`);
        this.renderer.setStyle(bar, 'margin', this.options.barMargin);
        this.renderer.appendChild(this.wrapper, bar);
        this.barVisibilityChange.emit(true);
    }
    /**
     * @return {?}
     */
    getBarHeight() {
        /** @type {?} */
        const elHeight = this.el.offsetHeight;
        /** @type {?} */
        const barHeight = Math.max((elHeight / this.el.scrollHeight) * elHeight, 30) + 'px';
        /** @type {?} */
        const display = parseInt(barHeight, 10) === elHeight ? 'none' : 'block';
        if (this.wrapper.offsetHeight !== elHeight) {
            this.renderer.setStyle(this.wrapper, 'height', elHeight + 'px');
        }
        this.renderer.setStyle(this.bar, 'height', barHeight);
        this.renderer.setStyle(this.bar, 'display', display);
        this.renderer.setStyle(this.grid, 'display', display);
        this.barVisibilityChange.emit(display !== 'none');
    }
    /**
     * @param {?} y
     * @param {?} duration
     * @param {?} easingFunc
     * @return {?}
     */
    scrollTo(y, duration, easingFunc) {
        /** @type {?} */
        const start = Date.now();
        /** @type {?} */
        const from = this.el.scrollTop;
        /** @type {?} */
        const maxTop = this.el.offsetHeight - this.bar.offsetHeight;
        /** @type {?} */
        const maxElScrollTop = this.el.scrollHeight - this.el.clientHeight;
        /** @type {?} */
        const barHeight = Math.max((this.el.offsetHeight / this.el.scrollHeight) * this.el.offsetHeight, 30);
        /** @type {?} */
        const paddingTop = parseInt(this.el.style.paddingTop, 10) || 0;
        /** @type {?} */
        const paddingBottom = parseInt(this.el.style.paddingBottom, 10) || 0;
        /** @type {?} */
        const scroll = (/**
         * @param {?} timestamp
         * @return {?}
         */
        (timestamp) => {
            /** @type {?} */
            const currentTime = Date.now();
            /** @type {?} */
            const time = Math.min(1, ((currentTime - start) / duration));
            /** @type {?} */
            const easedTime = easing[easingFunc](time);
            if (paddingTop > 0 || paddingBottom > 0) {
                /** @type {?} */
                let fromY = null;
                if (paddingTop > 0) {
                    fromY = -paddingTop;
                    fromY = -((easedTime * (y - fromY)) + fromY);
                    this.renderer.setStyle(this.el, 'paddingTop', `${fromY}px`);
                }
                if (paddingBottom > 0) {
                    fromY = paddingBottom;
                    fromY = ((easedTime * (y - fromY)) + fromY);
                    this.renderer.setStyle(this.el, 'paddingBottom', `${fromY}px`);
                }
            }
            else {
                this.el.scrollTop = (easedTime * (y - from)) + from;
            }
            /** @type {?} */
            const percentScroll = this.el.scrollTop / maxElScrollTop;
            if (paddingBottom === 0) {
                /** @type {?} */
                const delta = Math.round(Math.round(this.el.clientHeight * percentScroll) - barHeight);
                if (delta > 0) {
                    this.renderer.setStyle(this.bar, 'top', `${delta}px`);
                }
            }
            if (time < 1) {
                requestAnimationFrame(scroll);
            }
        });
        requestAnimationFrame(scroll);
    }
    /**
     * @param {?} y
     * @param {?} isWheel
     * @param {?} isJump
     * @return {?}
     */
    scrollContent(y, isWheel, isJump) {
        /** @type {?} */
        let delta = y;
        /** @type {?} */
        const maxTop = this.el.offsetHeight - this.bar.offsetHeight;
        /** @type {?} */
        const hiddenContent = this.el.scrollHeight - this.el.offsetHeight;
        /** @type {?} */
        let percentScroll;
        /** @type {?} */
        let over = null;
        if (isWheel) {
            delta = parseInt(getComputedStyle(this.bar).top, 10) + y * 20 / 100 * this.bar.offsetHeight;
            if (delta < 0 || delta > maxTop) {
                over = delta > maxTop ? delta - maxTop : delta;
            }
            delta = Math.min(Math.max(delta, 0), maxTop);
            delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);
            this.renderer.setStyle(this.bar, 'top', delta + 'px');
        }
        percentScroll = parseInt(getComputedStyle(this.bar).top, 10) / (this.el.offsetHeight - this.bar.offsetHeight);
        delta = percentScroll * hiddenContent;
        this.el.scrollTop = delta;
        this.showBarAndGrid();
        if (!this.options.alwaysVisible) {
            if (this.visibleTimeout) {
                clearTimeout(this.visibleTimeout);
            }
            this.visibleTimeout = setTimeout((/**
             * @return {?}
             */
            () => {
                this.hideBarAndGrid();
            }), this.options.visibleTimeout);
        }
        /** @type {?} */
        const isScrollAtStart = delta === 0;
        /** @type {?} */
        const isScrollAtEnd = delta === hiddenContent;
        /** @type {?} */
        const scrollPosition = Math.ceil(delta);
        /** @type {?} */
        const scrollState = new SlimScrollState({ scrollPosition, isScrollAtStart, isScrollAtEnd });
        this.scrollChanged.emit(scrollState);
        return over;
    }
    /**
     * @return {?}
     */
    showBarAndGrid() {
        this.renderer.setStyle(this.grid, 'background', this.options.gridBackground);
        this.renderer.setStyle(this.bar, 'background', this.options.barBackground);
    }
    /**
     * @return {?}
     */
    hideBarAndGrid() {
        this.renderer.setStyle(this.grid, 'background', 'transparent');
        this.renderer.setStyle(this.bar, 'background', 'transparent');
    }
    /**
     * @return {?}
     */
    destroy() {
        if (this.mutationObserver) {
            this.mutationObserver.disconnect();
            this.mutationObserver = null;
        }
        if (this.el.parentElement.classList.contains('slimscroll-wrapper')) {
            /** @type {?} */
            const wrapper = this.el.parentElement;
            /** @type {?} */
            const bar = wrapper.querySelector('.slimscroll-bar');
            wrapper.removeChild(bar);
            /** @type {?} */
            const grid = wrapper.querySelector('.slimscroll-grid');
            wrapper.removeChild(grid);
            this.unwrap(wrapper);
        }
        if (this.interactionSubscriptions) {
            this.interactionSubscriptions.unsubscribe();
        }
    }
    /**
     * @param {?} wrapper
     * @return {?}
     */
    unwrap(wrapper) {
        /** @type {?} */
        const docFrag = document.createDocumentFragment();
        while (wrapper.firstChild) {
            /** @type {?} */
            const child = wrapper.removeChild(wrapper.firstChild);
            docFrag.appendChild(child);
        }
        wrapper.parentNode.replaceChild(docFrag, wrapper);
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    onResize($event) {
        this.getBarHeight();
    }
}
SlimScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[slimScroll]',
                // tslint:disable-line
                exportAs: 'slimScroll'
            },] }
];
/** @nocollapse */
SlimScrollDirective.ctorParameters = () => [
    { type: ViewContainerRef, decorators: [{ type: Inject, args: [ViewContainerRef,] }] },
    { type: Renderer2, decorators: [{ type: Inject, args: [Renderer2,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [SLIMSCROLL_DEFAULTS,] }, { type: Optional }] }
];
SlimScrollDirective.propDecorators = {
    enabled: [{ type: Input }],
    options: [{ type: Input }],
    scrollEvents: [{ type: Input }],
    scrollChanged: [{ type: Output }],
    barVisibilityChange: [{ type: Output }],
    onResize: [{ type: HostListener, args: ['window:resize', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    SlimScrollDirective.prototype.enabled;
    /** @type {?} */
    SlimScrollDirective.prototype.options;
    /** @type {?} */
    SlimScrollDirective.prototype.scrollEvents;
    /** @type {?} */
    SlimScrollDirective.prototype.scrollChanged;
    /** @type {?} */
    SlimScrollDirective.prototype.barVisibilityChange;
    /** @type {?} */
    SlimScrollDirective.prototype.el;
    /** @type {?} */
    SlimScrollDirective.prototype.wrapper;
    /** @type {?} */
    SlimScrollDirective.prototype.grid;
    /** @type {?} */
    SlimScrollDirective.prototype.bar;
    /** @type {?} */
    SlimScrollDirective.prototype.body;
    /** @type {?} */
    SlimScrollDirective.prototype.pageY;
    /** @type {?} */
    SlimScrollDirective.prototype.top;
    /** @type {?} */
    SlimScrollDirective.prototype.dragging;
    /** @type {?} */
    SlimScrollDirective.prototype.mutationThrottleTimeout;
    /** @type {?} */
    SlimScrollDirective.prototype.mutationObserver;
    /** @type {?} */
    SlimScrollDirective.prototype.lastTouchPositionY;
    /** @type {?} */
    SlimScrollDirective.prototype.visibleTimeout;
    /** @type {?} */
    SlimScrollDirective.prototype.interactionSubscriptions;
    /** @type {?} */
    SlimScrollDirective.prototype.initWheel;
    /** @type {?} */
    SlimScrollDirective.prototype.initDrag;
    /** @type {?} */
    SlimScrollDirective.prototype.preventDefaultEvent;
    /**
     * @type {?}
     * @private
     */
    SlimScrollDirective.prototype.viewContainer;
    /**
     * @type {?}
     * @private
     */
    SlimScrollDirective.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    SlimScrollDirective.prototype.document;
    /**
     * @type {?}
     * @private
     */
    SlimScrollDirective.prototype.optionsDefaults;
}

/**
 * @fileoverview added by tsickle
 * Generated from: src/module/ngx-slimscroll.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgSlimScrollModule {
}
NgSlimScrollModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SlimScrollDirective
                ],
                exports: [
                    SlimScrollDirective
                ]
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: public_api.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-slimscroll.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgSlimScrollModule, SLIMSCROLL_DEFAULTS, SlimScrollDirective, SlimScrollEvent, SlimScrollOptions, easing };
//# sourceMappingURL=ngx-slimscroll.js.map
